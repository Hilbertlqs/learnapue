11.1
采用动态分配内存代替使用自动变量。
goodexit2.c

11.2
要改变挂起作业的线程ID，必须持有写模式下的读写锁，防止ID在改变过程中有其他线程在搜索该列表。目前定义该接口的方式存在的问题在于：调用job_find找到该作业以及调用job_remove从列表中删除该作业这两个时间之间作业ID可以改动。这个问题可以通过在job结构中嵌入引用计数和互斥量，然后让job_find增加引用计数的方法来解决。这样修改ID的代码就可以避免对列表中非零引用计数的任何作业进行ID改动的情况。

11.3
首先，列表是由读写锁保护的，但条件变量需要互斥量对条件进行保护。其次，每个线程等待满足的条件应该是有某个作业进行处理时需要的条件，所以需要创建每线程数据结构来表示这个条件。或者，可以把互斥量和条件变量嵌入到queue结构中，但这意味着所有的工作线程将等待相同的条件。如果有很多工作线程存在，当唤醒了许多线程但又没有工作可做时，就可能出现惊群效应问题，最后导致CPU资源的浪费，并且增加了锁的争夺。

11.4
这根据具体情况而定。总的来说，两种情况都可能是正确的，但每一种方法都有不足之处。在第一种情况下，等待线程会被安排在调用pthread_cond_broadcast之后运行。如果程序运行在多处理器上，由于还持有互斥锁(pthread_cond_wait返回持有的互斥锁)，一些线程就会运行而且马上阻塞。在第二种情况下，运行线程可以在第3步和第4步之间获取互斥锁，然后使条件失效，最后释放互斥锁。接着，当调用pthread_cond_broadcast时，条件不再为真，线程无需运行。这就是为什么唤醒线程必须重新检查条件，不能仅仅因为pthread_cond_wait返回就假定条件就为真。

11.5

